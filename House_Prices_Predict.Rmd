---
title: "House Prices Prediction"
author: "Valentin Henriot"
date: "7/22/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE)
```

```{r}
library(tidyverse)
library(ggplot2) # data visualization
library(readr) # download the data
library(caret) # to perform RF model
library(naniar) # to visualize missing data
library(data.table) # to ?????????
library(corrr) # pour les corrélations entre variables
```

# Chargement du jeu de données

```{r}
train.df <- read_csv("trainhouseprices.csv")
test.df <- read_csv("testhouseprices.csv")

train.df$TrainData <- TRUE 
test.df$TrainData <- FALSE
```

```{r}
#str(train.df)
```

We can see that train.df contains 82 variables.

```{r}
#str(test.df)
```

test.df contains only 81 variables, one less than train.df, we see that it is the variable SalePrice that is missing.

```{r}
test.df$SalePrice <- NA
```

We add the variable SalePrice with the value NA for the test dataset.

```{r}
full.df <- rbind(train.df, test.df)
```

We merge the two datasets to perform analysis on the full data.

```{r}
head(full.df, 10)
```

Nous regardons les dix premières lignes de notre jeu de données, nous pouvons constater que certaines variables comportent des valeurs manquantes. Nous allons donc étudier quelles sont les valeurs manquantes puis essayer de définir une méthode pour les prédire.

# Gérer les valeurs manquantes

### NA sur la globalité du jeu de données

```{r}
na_count <-sapply(full.df, function(y) sum(length(which(is.na(y)))))

na_count <- data.frame(na_count)

na_count <- rownames_to_column(na_count)
na_count <- filter(na_count, na_count > 0)
na_count
```

Nous pouvons voir que les variables qui comptent le plus de valeurs manquantes sont Alley, PoolQc, MiscFeature, Fence, FirePlaceQu. Il y a 29 variables qui contiennent des valeurs nulles mais dans une moindre mesure. Il sera donc plus simple de les prédire. Enfin, la variable SalePrice contient 1459 valeurs manquantes soit le nombre de lignes du jeu de données test.

```{r}
gg_miss_var(full.df)
```

Une autre manière de visualiser les valeurs manquantes de façon hiérarchique. Sur ce graphique, nous distinguons clairement 6 variables pour lesquelles nous avons plus de 1000 valeurs nulles.

Analyse des variables qui contiennent le plus de NA:

+ PoolQC, la valeur NA indique une absence de piscine, il n'y a donc aucune valeur à modifier.
+ MiscFeature, là encore, la valeur NA indique l'absence de caractéristiques supplémentaires.
+ Alley, la valeur NA indique l'absence d'allée.
+ Fence, la valeur NA indique l'absence de clôtures.
+ FireplaceQu, la valeur NA indique l'absence de cheminée.
+ LotFrontage, ici, il va falloir déterminer si NA indique l'absence de distance entre la propriété et la rue ou alors si la valeur NA indique simplement une valeur non renseignée.

Pour éviter de fausser l'analyse de données, nous allons remplacer les valeurs NA des cinq premières variables par "No".
Concernant la variable LotFrontage, nous allons devoir déterminer si NA indique une distance de 0 ou s'il s'agit de valeurs non renseignées.

### NA indiquant "non"

```{r}
full.df$PoolQC[is.na(full.df$PoolQC)] = "No"
full.df$MiscFeature[is.na(full.df$MiscFeature)] = "No"
full.df$Alley[is.na(full.df$Alley)] = "No"
full.df$Fence[is.na(full.df$Fence)] = "No"
full.df$FireplaceQu[is.na(full.df$FireplaceQu)] = "No"
```

Les valeurs indiquées comme NA pour les précédentes variables ont donc été remplacées par la valeur "No", cela permettra de passer ces variables en facteur au moment voulu.

## Remplacement des NA sur les autres variables

### Variable PoolQC

```{r}
full.df[full.df$PoolArea>0 & full.df$PoolQC=="No", c("Id", 'PoolArea', 'PoolQC', 'OverallQual')]
```

Nous constatons qu'il y a 3 valeurs "No" pour la variable PoolQC alors que la variable PoolArea indique une taille de piscine (donc la présence d'une piscine sur la propriété). Il s'agit donc d'une erreur de saisie ou d'une omission pour la variable PoolQC sur les lignes.
Pour remplacer les valeurs manquantes de PoolQC, nous nous baserons sur la qualité globale de la maison (en divisant par 2).

```{r}
full.df$PoolQC[2421] <- "Fa"
full.df$PoolQC[2504] <- "TA"
full.df$PoolQC[2600] <- "Fa"
```

Les valeurs ont été remplacées en prenant en compte la qualité globale de l'habitation.

### Variable FirePlaceQu

```{r}
full.df[full.df$Fireplaces>0 & full.df$FireplaceQu=="No", c("Id", 'Fireplaces', 'FireplaceQu')]
```

Il n'y a aucune erreur sur la variable FirePlaceQu, car lorsque la valeur indique "No", il y a effectivement aucune cheminée au sein de l'habitation.

### Variable LotFrontage

```{r}
summary(full.df$LotFrontage)
```

Cette première analyse nous permet de constater que pour la variable LotFrontage, la valeur minimum est 21. Nous ne pouvons donc pas conclure que les valeurs NA représentent la valeur 0. 

```{r}
table(is.na(full.df$LotFrontage), full.df$MSZoning)
```

Dans un premier temps, nous essayons de voir s'il existe un lien entre la variable MsZoning et la variable LotFrontage. Nous décidons de faire cette analyse car il pourrait y avoir un lien par exemple entre le fait d'être en zone agricole et ainsi ne pas avoir de surface du lot bordant la rue. 

Nous constatons que les valeurs manquantes pour LotFrontage semblent être distribuées de façon identique aux valeurs non-nulles de la variable. Il n'y a donc à priori aucun lien entre ces deux variables.

En étudiant les autres variables du jeu de données, nous nous apercevons qu'aucune autre ne semble pouvoir expliquer les absences de valeurs pour la variable LotFrontage. Nous allons donc devoir trouver une méthode pour prédire les valeurs de cette dernière.

```{r}
ggplot(full.df[!is.na(full.df$LotFrontage),], aes(x=as.factor(Neighborhood), y=LotFrontage)) +
        geom_bar(stat='summary', fun.y = "median", fill='red') +
        theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

Nous voyons que les valeurs pour LotFrontage divergent en fonction du lieu. Nous allons donc affecter les valeurs médianes aux valeurs manquantes pour cette variable.

```{r}
full.df <- data.table(full.df)
setkey(full.df, Neighborhood)
full.df[,LotFrontage := ifelse(is.na(LotFrontage), median(LotFrontage, na.rm=TRUE), LotFrontage), by=Neighborhood]

full.df <- full.df[order(full.df$Id),]
```

### Variables relatives au Garage

Pour GarageType, la valeur NA indique l'absence de garage. Il faut donc regarder pour les autres variables garages si l'absence d'informations provient de l'absence d'un garage.

Nombre de valeurs manquantes pour les variables rattachées au Garage :

GarageType	157			
GarageYrBlt	159			
GarageFinish	159			
GarageCars	1			
GarageArea	1			
GarageQual	159			
GarageCond	159

Dans un premier temps, nous indiquons "Abs" lorsque la valeur NA est présente sur la variable GarageType.

```{r}
full.df$GarageType[is.na(full.df$GarageType)] = "Abs"
```

Ensuite nous créons un jeu de données avec l'ensemble des variables Garage (voir si c'est pertinent)

```{r}
full.df[full.df$GarageType=="Abs", c("GarageYrBlt", 'GarageQual', 'GarageCond', 'GarageFinish')]
```
Nous pouvons voir que parmi toutes les valeurs Abs pour la variable GarageType, les variables GarageYrBlt, GarageQual, GarageCond et GarageFinish affichent une valeur "NA". Ainsi, nous allons pouvoir remplacer ces NA par la valeur Abs.

```{r}
full.df$GarageYrBlt[is.na(full.df$GarageYrBlt)] = "Abs"
full.df$GarageQual[is.na(full.df$GarageQual)] = "Abs"
full.df$GarageCond[is.na(full.df$GarageCond)] = "Abs"
full.df$GarageFinish[is.na(full.df$GarageFinish)] = "Abs"
```

Les variables GarageCars et GarageArea comptent chacune une valeur NA, nous allons vérifier si cette valeur NA correspond à l'absence de garage ou s'il s'agit d'une erreur de saisie lors de la création du jeu de données.

```{r}
which(is.na(full.df$GarageCars), arr.ind=TRUE)
which(is.na(full.df$GarageArea), arr.ind=TRUE)
```

Nous pouvons voir que les 2 valeurs manquantes pour les 2 variables se trouvent sur la même ligne, la ligne 2577.

```{r}
full.df[2577]
```

Sur la ligne 2577, toutes les variables relatives au Garage indiquent l'absence d'un garage excepté pour la variable GarageType qui indique "Detchd", nous pouvons donc conclure qu'il s'agit d'une erreur de saisie et que cette valeur devrait être "Abs" au lieu de "Detchd".

```{r}
full.df$GarageType[2577] <- "Abs"
full.df$GarageCars[is.na(full.df$GarageCars)] = "Abs"
full.df$GarageArea[is.na(full.df$GarageArea)] = "Abs"
```

### Variables MasVnrArea/MasVnrType

```{r}
summary(full.df$MasVnrArea)
```

La moyenne de la variable MasVnrArea (qui indique la surface de placage sur les façades) est de 102.2m² alors que la médiane est de 0, donc au moins la moitié des valeurs pour cette variable sont nulles, vérifions s'il s'agit d'une erreur.

```{r}
full.df$MasVnrArea <- as.numeric(full.df$MasVnrArea)
table(full.df$MasVnrArea==0, full.df$MasVnrType) 
```

Après avoir filtré la base de données pour ne garder que les habitations qui ont une valeur MasVnrArea égale à zéro, on remarque qu'il y a une corrélation entre les variables MasVnrArea et MasVnrType (qui indique le type de placage) : pour toutes les habitations qui ont une valeur MasVnrArea nulle, la variable MasVnrType indique "None". Donc il ne s'agit pas d'une erreur puisque les valeurs nulles correspondent aux habitations dont les façades ne possèdent pas de placage). Néanmoins, il y a 3 valeurs pour lesquelles MasVnrArea indique 0 alors que MasVnrType indique BrkFace ou Stone. Nous allons donc chercher ces 3 valeurs dans un premier temps. Il existe également 7 habitations ne possédant pas une valeur nulle pour MasVnrArea alors que le MasVnrType est None.
 
```{r}
which(full.df$MasVnrArea==0 & full.df$MasVnrType=="BrkFace", arr.ind=TRUE)
which(full.df$MasVnrArea==0 & full.df$MasVnrType=="Stone", arr.ind=TRUE)
```

Nous remarquons que les lignes qui posent problème sont les suivantes : 689 / 2320 et 1242.
Nous allons chercher parmi les variables numériques s'il existe une corrélation avec MasVnrArea.

```{r}
full.df %>% 
  select("MasVnrArea", "TotalBsmtSF") %>% 
  correlate() %>% 
  rearrange() %>%  
   shave() 
```

La corrélation la plus élevée que nous trouvons est avec la variable TotalBsmtSF. Toutefois, le résultat est de 0,39, la corrélation est donc faible et nous ne pouvons pas nous baser sur cette variable pour remplir les valeurs manquantes.

Nous allons donc regarder les moyennes pour  les valeurs manquantes de la variable MasVnrArea indiquant BrkFace ou Stone pour la variable MasVnrType.

```{r}
BrkNum <- mean(full.df$MasVnrArea[full.df$MasVnrType=="BrkFace"], na.rm = TRUE) 
StoneNum <- mean(full.df$MasVnrArea[full.df$MasVnrType=="Stone"], na.rm = TRUE)
```

Nous pouvons voir que la moyenne MasVnrArea pour MasVnrType = BrkFace est de 261.67. Elle est de 239.55 pour MasVnrType = Stone.
Nous allons donc utiliser ces deux valeurs pour remplacer les valeurs NA de la variable MasVnrArea.

```{r}
full.df$MasVnrArea[689] <- BrkNum
full.df$MasVnrArea[2320] <- BrkNum
full.df$MasVnrArea[1242] <- StoneNum
```

Nous allons maintenant nous intéresser aux valeurs none de la variable MasVnrType lorsque MasVnrArea est supérieure à 0. Nous devrions retrouver 7 valeurs.

```{r}
which(full.df$MasVnrArea>0 & full.df$MasVnrType=="None", arr.ind=TRUE)
```

```{r}
full.df$MasVnrArea[625] # tester pour chaque ligne
```

Voici les valeurs trouvées pour les différentes lignes :
Ligne 625 -> 288
Ligne 774 -> 1
Ligne 1231 -> 1
Ligne 1301 -> 344
Ligne 1335 -> 312
Ligne 1670 -> 285
Ligne 2453 -> 1

Nous allons vérifier pour les lignes affichant la valeur 1 s'il ne s'agit pas d'une erreur.

```{r}
which(full.df$MasVnrArea==1, arr.ind=TRUE)
```

Nous remarquons en effectuant une recherche sur le jeu de données complet qu'il s'agit des mêmes lignes. Nous pouvons donc conclure à une erreur et remplacer ces valeurs 1 par la valeur 0.

```{r}
full.df$MasVnrArea[774] <- 0
full.df$MasVnrArea[1231] <- 0
full.df$MasVnrArea[2453] <- 0
```

Pour les 4 lignes affichant des valeurs supérieures à 1, nous allons vérifier s'il existe une corrélation entre le lieu d'habitation et le type de façade.

```{r}
table(full.df$MasVnrType, full.df$Neighborhood)
```

Nous remarquons que la majorité des villes ont une majorité de maison avec une façade de type BrkFace ou alors None. Nous allons toutefois vérifier les 4 lignes pour vérifier dans quelles villes se trouvent ces 4 habitations.

```{r}
full.df$Neighborhood[625]
full.df$Neighborhood[1301]
full.df$Neighborhood[1335]
full.df$Neighborhood[1670]
```

Pour effectuer les remplacements de valeurs, nous choisirons le type de façade le plus présent dans la ville en question (autre que None).

```{r}
full.df$MasVnrType[625] <- "BrkFace"
full.df$MasVnrType[1301] <- "BrkFace"
full.df$MasVnrType[1335] <- "BrkFace"
full.df$MasVnrType[1670] <- "Stone"
```

Nous allons revérifier s'il existe des valeurs manquantes ou incohérentes.

```{r}
table(full.df$MasVnrArea==0, full.df$MasVnrType) 
```

Nous allons maintenant nous occuper des valeurs NA pour MasVnrArea et MasVnrType.

--------------------------------------------------------------------------------

```{r}
full.df$MasVnrType[is.na(full.df$MasVnrType)] = "None"
full.df$MasVnrArea[is.na(full.df$MasVnrArea)] = 0
```

En revanche, étant donné qu'il y a 24 valeurs manquantes pour le type de matériau et seulement 23 pour la surface couverte çela veut dire qu'il y a eu une erreur de saisie ou un oubli pour le matériau d'une habitation (car la surface est bien présente). 
Vérifions quels sont les matériaux les plus utilisées pour le placage.

```{r}
Graph3 <- ggplot(full.df) +
 aes(x = MasVnrType) +
 geom_bar(fill = "#0c4c8a") +
 theme_minimal()
ggplotly(Graph3)
```

Ce graphique nous montre qu'au total il y a 1153 (879 + 25 + 249) habitations qui ont un placage. Le matériau le plus utilisé est clairement la brique qui représente 76% (879/1153) des placages. On peut donc affirmer avec une certitude de 76% que la valeur manquante est BrkFace, ce qui est un risque acceptable.

```{r}
full.df[2611, 26] = "BrkFace"
```

```{r}
Graph10 <- gg_miss_var(full.df)
ggplotly(Graph10)
```

Il va maintenant falloir passer aux variables Bsmt (sous-sol)